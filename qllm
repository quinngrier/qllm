#! /usr/bin/env bash

#
# The authors of this file have waived all copyright and
# related or neighboring rights to the extent permitted by
# law as described by the CC0 1.0 Universal Public Domain
# Dedication. You should have received a copy of the full
# dedication along with this file, typically as a file
# named <CC0-1.0.txt>. If not, it may be available at
# <https://creativecommons.org/publicdomain/zero/1.0/>.
#

set -E -e -o pipefail -u || exit $?
trap exit ERR

#-----------------------------------------------------------------------
# search_up <&r> <p>
#-----------------------------------------------------------------------
#
# Starting from the current directory, search up the directory tree for
# the path <p> to exist. If found, set <&r> to an absolute path to the
# first such existent result. Otherwise, set <&r> to be empty.
#

search_up() {
  local -n search_up__r=$1
  local search_up__d="$PWD"
  while [[ $search_up__d ]]; do
    search_up__r=${search_up__d%/}/$2
    if [[ -e $search_up__r ]]; then
      return
    fi
    search_up__d=${search_up__d%/*}
  done
  search_up__r=
}; readonly -f search_up

#-----------------------------------------------------------------------
# search_up_or_home <&r> <p>
#-----------------------------------------------------------------------
#
# Like search_up(), but also search $HOME at the end.
#

search_up_or_home() {
  local -n search_up_or_home__r=$1
  search_up search_up_or_home__r "$2"
  if [[ ! $search_up_or_home__r && -e $HOME/$2 ]]; then
    search_up_or_home__r=$HOME/$2
  fi
}; readonly -f search_up_or_home

#-----------------------------------------------------------------------

declare -r \
  default_system_prompt="You and the user are experts. Keep your answers short. Don't show any personality." \
  nl=$'\n' \
  qllm_dir_name=.qllm \
  sq=\' \
;

system_prompt=$default_system_prompt

search_up_or_home x $qllm_dir_name/system_prompts/default
if [[ $x ]]; then
  system_prompt=$(<"$x")
fi

#-----------------------------------------------------------------------
# Parse the command-line arguments
#-----------------------------------------------------------------------

declare -A -r short_to_long=(
  [-d]=--debug
  [-m]=--model
)

parse_options=1

unset session_file

while (($# > 0)); do

  if ((parse_options)); then

    #-------------------------------------------------------------------
    # Options terminator
    #-------------------------------------------------------------------

    case $1 in (--)
      parse_options=0
      shift
      continue

    #-------------------------------------------------------------------
    # --debug, -d
    #-------------------------------------------------------------------

    ;; (--debug)
      QLLM_DEBUG=
      shift
      continue

    #-------------------------------------------------------------------
    # --model=<model>, -m <model>
    #-------------------------------------------------------------------

    ;; (--model=*)
      QLLM_MODEL=${1#*=}
      shift
      continue

    #-------------------------------------------------------------------
    # Long options with required arguments: --foo bar to --foo=bar
    #-------------------------------------------------------------------

    ;; ( \
      --model \
    )
      if (($# < 2)); then
        printf '%s\n' "$0: $1 requires an argument" >&2
        exit 1
      fi
      x=$1=$2
      shift 2
      set -- "$x" "$@"
      continue

    #-------------------------------------------------------------------
    # Short options with required arguments: -f bar to --foo=bar
    #-------------------------------------------------------------------

    ;; (-[m])
      if (($# < 2)); then
        printf '%s\n' "$0: $1 requires an argument" >&2
        exit 1
      fi
      x=${short_to_long[$1]}=$2
      shift 2
      set -- "$x" "$@"
      continue

    #-------------------------------------------------------------------
    # Short options with required arguments: -fbar to --foo=bar
    #-------------------------------------------------------------------

    ;; (-[m]?*)
      x=${short_to_long[${1:0:2}]}=${1:2}
      shift
      set -- "$x" "$@"
      continue

    #-------------------------------------------------------------------
    # Short options with forbidden arguments: -f to --foo
    #-------------------------------------------------------------------

    ;; (-[d])
      x=${short_to_long[$1]}
      shift
      set -- "$x" "$@"
      continue

    #-------------------------------------------------------------------
    # Short options with forbidden arguments: -fbar to --foo -bar
    #-------------------------------------------------------------------

    ;; (-[d]?*)
      x=${short_to_long[${1:0:2}]}
      y=-${1:2}
      shift
      set -- "$x" "$y" "$@"
      continue

    #-------------------------------------------------------------------
    # Long options incorrectly given arguments
    #-------------------------------------------------------------------

    ;; ( \
      --=* \
    )
      x=${1%%=*}
      printf '%s\n' "$0: $x forbids an argument" >&2
      exit 1

    #-------------------------------------------------------------------
    # Unknown long options
    #-------------------------------------------------------------------

    ;; (--*)
      x=${1%%=*}
      printf '%s\n' "$0: Unknown option: ${x@Q}" >&2
      exit 1

    #-------------------------------------------------------------------
    # Unknown short options
    #-------------------------------------------------------------------

    ;; (-?*)
      x=${1:0:2}
      printf '%s\n' "$0: Unknown option: ${x@Q}" >&2
      exit 1

    #-------------------------------------------------------------------
    esac
  fi

  if [[ ! ${session_file+x} ]]; then
    session_file=$1
  else
    printf '%s\n' "$0: Too many operands" >&2
    exit 1
  fi

  shift

done

if [[ ! ${session_file+x} ]]; then
  session_file=default.qllm
fi

if [[ ! ${QLLM_MODEL+x} ]]; then
  QLLM_MODEL=vertex-gemini-2.5-flash
fi

#-----------------------------------------------------------------------

unset vertex_bearer

vertex_init() {
  if [[ ! ${vertex_bearer+x} ]]; then
    vertex_bearer=$(gcloud auth print-access-token)
    vertex_project=$(gcloud config get-value project)
    vertex_location=us-central1
  fi
  completions_url="https://aiplatform.googleapis.com/v1beta1/projects/$vertex_project/locations/$vertex_location/endpoints/openapi/chat/completions"
  completions_bearer=$vertex_bearer
}; readonly -f vertex_init

#-----------------------------------------------------------------------

declare -A -r model_map=(
  # Listed in Google Cloud's web UI under Vertex AI > Model Garden.
  [vertex-gemini-2.5-flash]="google/gemini-2.5-flash"
  [vertex-gemini-2.5-pro]="google/gemini-2.5-pro"
  [vertex-gemini-3-pro-preview]="google/gemini-3-pro-preview"
)

declare -A -r init_functions=(
  [vertex-gemini-2.5-flash]=vertex_init
  [vertex-gemini-2.5-pro]=vertex_init
  [vertex-gemini-3-pro-preview]=vertex_init
)

editor="${EDITOR-vi} ${EDITOR_BOTTOM-}"
gawk=gawk

printf -v blank_heading -- -%.s {1..72}
readonly blank_heading

user_heading='@@@ user '
user_heading+=${blank_heading:${#user_heading}}
readonly user_heading

model_heading='@@@ model '
model_heading+=${blank_heading:${#model_heading}}
readonly model_heading

#-----------------------------------------------------------------------

declare -r qllm_to_completions_gawk='

  function barf(message) {
    print(argv0 ": " message) >"/dev/stderr";
    exit_status = 1;
    exit exit_status;
  }

  function command_filter(x, c,    s) {
    printf("%s", x) |& c;
    s = close(c, "to");
    if (s != 0) {
      barf("Command failed: " c);
    }
    c |& getline x;
    s = close(c);
    if (s != 0) {
      barf("Command failed: " c);
    }
    return x;
  }

  function json_quote(x) {
    return command_filter(x, "jq -R -s .");
  }

  function base64_encode(x) {
    return command_filter(x, "base64");
  }

  function read_text_file(f,    xs, s, x) {
    xs = "";
    while ((s = (getline x < f)) > 0) {
      sub("[\t ]+$", "", x);
      xs = xs x "\n";
    }
    if (s < 0) {
      barf("Error reading file " json_quote(f));
    }
    s = close(f);
    if (s != 0) {
      barf("Error closing file " json_quote(f));
    }
    sub("^\n+", "", xs);
    sub("\n+$", "", xs);
    return xs;
  }

  function get_fence_type(filename) {
    if (filename ~ /\.[ch]$/) {
      return "c";
    }
    return "";
  }

  function add_text_content(    x, y) {
    x = buffer;
    buffer = "";
    if (heredoc) {
      if (x) {
        x = x "\n";
      }
      y = "Here is the file `" heredoc "`:\n\n";
      x = y "```" get_fence_type(heredoc) "\n" x "```";
      heredoc = "";
    } else {
      sub("^[\n ]*", "", x);
      sub("[\n ]*$", "", x);
      if (!x) {
        return;
      }
    }
    x = json_quote(x);
    if (content) {
      content = content ", ";
    }
    content = content "{";
    content = content "\"type\": \"text\", ";
    content = content "\"text\": " x;
    content = content "}";
  }

  function add_message(role) {
    if (content) {
      content = "[" content "]";
    } else {
      content = "\" \"";
    }
    if (messages) {
      messages = messages ", ";
    }
    messages = messages "{";
    messages = messages "\"role\": \"" role "\", ";
    messages = messages "\"content\": " content;
    messages = messages "}";
    content = "";
  }

  BEGIN {
    buffer = system_prompt;
    add_text_content();
    add_message("system");
    role = "user";
  }

  {
    if (/^@@@ *user[ -]*$/) {
      if (role == "assistant") {
        add_text_content();
        add_message(role);
        role = "user";
      }
    } else if (/^@@@ *model[ -]*$/) {
      if (role == "user") {
        add_text_content();
        add_message(role);
        role = "assistant";
      }
    } else if (role == "user") {
      if (sub(/^@@@ *<< */, "")) {
        sub(/ *$/, "");
        if (!$0 && !heredoc) {
          barf("Orphan @@@<< block terminator");
        }
        add_text_content();
        heredoc = $0;
      } else if (sub(/^@@@ *< */, "")) {
        sub(/ *$/, "");
        if (!$0) {
          barf("The @@@< directive requires a filename");
        }
        if (heredoc) {
          barf("The @@@< directive cannot be used in a @@@<< block");
        }
        add_text_content();
        heredoc = $0;
        buffer = read_text_file(heredoc);
        add_text_content();
      } else if (/^@@@/) {
        barf("Unknown directive: " $0);
      } else {
        if (buffer) {
          buffer = buffer "\n";
        }
        buffer = buffer $0;
      }
    } else {
      if (/^@@@/) {
        barf("Unknown directive: " $0);
      }
      if (buffer) {
        buffer = buffer "\n";
      }
      buffer = buffer $0;
    }
  }

  END {
    if (exit_status) {
      exit exit_status;
    }
    add_text_content(buffer);
    add_message(role);
    body = "{";
    body = body "\"model\": " json_quote(model) ", ";
    body = body "\"messages\": [" messages "], ";
    body = body "\"tools\": [" tools "]";
    body = body "}";
    print body;
  }

'

#-----------------------------------------------------------------------

while :; do

  model=${model_map[$QLLM_MODEL]-}
  if [[ ! $model ]]; then
    printf '%s\n' "$0: Unknown model: ${QLLM_MODEL@Q}" >&2
    exit 1
  fi

  ${init_functions[$QLLM_MODEL]}

  if [[ -s "$session_file" ]]; then
    x=$(tail -n 3 -- "$session_file"; echo x)
    if [[ $x != "$user_heading"$'\n\n\nx' ]]; then
      printf '\n\n%s\n\n\n' "$user_heading" >>"$session_file"
    fi
  else
    printf '%s\n\n\n' "$user_heading" >>"$session_file"
  fi

  hash1=$(sha256sum -b -- "$session_file")

  eval " $editor -- ${session_file@Q}"

  hash2=$(sha256sum -b -- "$session_file")

  if [[ $hash1 == "$hash2" ]]; then
    break
  fi

  completions_request=$(
    eval " $gawk"' \
      -v argv0="$0" \
      -v model="$model" \
      -v sq="$sq" \
      -v system_prompt="$system_prompt" \
      -- \
      "$qllm_to_completions_gawk" \
      "$session_file" \
    ;'
  )

  if [[ ${QLLM_DEBUG+x} ]]; then

    printf 'completions_request = %s\n' "$completions_request" >&2

    x=$(jq . <<<"$completions_request" 2>&1 || :)
    printf 'parsed_completions_request = %s\n' "$x" >&2

  fi

  curl -L -S -f -s \
    -X POST \
    --url "$completions_url" \
    -H "Authorization: Bearer $completions_bearer" \
    -H "Content-Type: application/json" \
    --data-binary @- \
    <<<"$completions_request" \
  | jq -r '.choices[0].message.content' | {
    printf '\n\n%s\n\n' "$model_heading"
    cat
  } >>"$session_file"

done
