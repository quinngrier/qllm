#! /usr/bin/env bash

#
# The authors of this file have waived all copyright and
# related or neighboring rights to the extent permitted by
# law as described by the CC0 1.0 Universal Public Domain
# Dedication. You should have received a copy of the full
# dedication along with this file, typically as a file
# named <CC0-1.0.txt>. If not, it may be available at
# <https://creativecommons.org/publicdomain/zero/1.0/>.
#

#
# This is qllm, a large language model CLI.
#
# See <https://github.com/quinngrier/qllm>.
#

#-----------------------------------------------------------------------
# Set up initial error handling
#-----------------------------------------------------------------------

set -e -u || exit

#-----------------------------------------------------------------------
# Set up qsh
#-----------------------------------------------------------------------
#
# This section was generated using qsh.
# See <https://github.com/quinngrier/qsh>.
#
# The authors of this section have waived all copyright and
# related or neighboring rights to the extent permitted by
# law as described by the CC0 1.0 Universal Public Domain
# Dedication. You should have received a copy of the full
# dedication along with this file, typically as a file
# named <CC0-1.0.txt>. If not, it may be available at
# <https://creativecommons.org/publicdomain/zero/1.0/>.
#

qsh_barf() {

  case $# in (0)
    set "Unknown error"
  esac

  qsh_barf_message="$0: Error:"
  for qsh_barf_text; do
    qsh_barf_message="$qsh_barf_message $qsh_barf_text"
  done
  qsh_barf_message=$qsh_barf_message.

  printf '%s\n' "$qsh_barf_message" >&2

  exit "${qsh_exit_status-1}"

}

qsh_warn() {

  case $# in (0)
    set "Unknown warning"
  esac

  qsh_warn_message="$0: Warning:"
  for qsh_warn_text; do
    qsh_warn_message="$qsh_warn_message $qsh_warn_text"
  done
  qsh_warn_message=$qsh_warn_message.

  printf '%s\n' "$qsh_warn_message" >&2

}

#-----------------------------------------------------------------------
# Set up Bash
#-----------------------------------------------------------------------

case ${BASH_VERSINFO-} in ('' | *[!0-9]* | 0* | [0-4])
  qsh_barf \
    "This script requires Bash version 5.0 or later." \
    "You have version ${BASH_VERSION-unknown}" \
  ;
esac

set -o pipefail

shopt -s \
  inherit_errexit \
;

#-----------------------------------------------------------------------
# search_up <&r> <p>
#-----------------------------------------------------------------------
#
# Starting from the current directory, search up the directory tree for
# the path <p> to exist. If found, set <&r> to an absolute path to the
# first such existent result. Otherwise, set <&r> to be empty.
#

search_up() {
  local -n search_up__r=$1
  local search_up__d="$PWD"
  while [[ $search_up__d ]]; do
    search_up__r=${search_up__d%/}/$2
    if [[ -e $search_up__r ]]; then
      return
    fi
    search_up__d=${search_up__d%/*}
  done
  search_up__r=
}; readonly -f search_up

#-----------------------------------------------------------------------
# search_up_or_home <&r> <p>
#-----------------------------------------------------------------------
#
# Like search_up(), but also search $HOME at the end, if needed.
#

search_up_or_home() {
  local -n search_up_or_home__r=$1
  search_up search_up_or_home__r "$2"
  if [[ ! $search_up_or_home__r && -e $HOME/$2 ]]; then
    search_up_or_home__r=$HOME/$2
  fi
}; readonly -f search_up_or_home

#-----------------------------------------------------------------------
# curl_with_retries <&response_body> <request_body>
#                   <success_code_regex> <retry_code_regex>
#                   <arg>...
#-----------------------------------------------------------------------

curl_with_retries() {

  local -n curl_with_retries__response_body="$1"
  shift

  local -r request_body="$1"
  shift

  local -r success_code_regex="$1"
  shift

  local -r retry_code_regex="$1"
  shift

  local -r max_retries=4
  local -r write_out='\n%{http_code}'

  local num_retries=0
  local retry_delay=1
  local response_body
  local response_code
  while :; do
    if [[ $request_body ]]; then
      response_body=$(
        curl -L -S -s \
          -w "$write_out" \
          "$@" \
          <<<"$request_body" \
        ;
      )
    else
      response_body=$(
        curl -L -S -s \
          -w "$write_out" \
          "$@" \
        ;
      )
    fi
    response_code=${response_body##*$'\n'}
    response_body=${response_body%$'\n'*}
    if [[ $response_code =~ $success_code_regex ]]; then
      break
    elif [[ $response_code =~ $retry_code_regex ]]; then
      if ((++num_retries > max_retries)); then
        qsh_barf "HTTPS request retry limit exceeded"
      fi
      ((retry_delay *= 2))
      qsh_warn "HTTPS request failed with response code $response_code"
      sleep $retry_delay
      continue
    else
      qsh_barf "HTTPS request failed with response code $response_code"
    fi
  done

  curl_with_retries__response_body=$response_body

}; readonly -f curl_with_retries

#-----------------------------------------------------------------------

declare -r \
  default_system_prompt="You and the user are experts. Keep your answers short. Don't show any personality." \
  nl=$'\n' \
  qllm_dir_name=.qllm \
  sq=\' \
;

system_prompt=$default_system_prompt

search_up_or_home x $qllm_dir_name/system_prompts/default
if [[ $x ]]; then
  system_prompt=$(<"$x")
fi

#-----------------------------------------------------------------------
# Parse the command-line arguments
#-----------------------------------------------------------------------

declare -A -r short_to_long=(
  [-d]=--debug
  [-m]=--model
)

parse_options=1

unset session_file

while (($# > 0)); do

  if ((parse_options)); then

    #-------------------------------------------------------------------
    # Options terminator
    #-------------------------------------------------------------------

    case $1 in (--)
      parse_options=0
      shift
      continue

    #-------------------------------------------------------------------
    # --debug, -d
    #-------------------------------------------------------------------

    ;; (--debug)
      QLLM_DEBUG=
      shift
      continue

    #-------------------------------------------------------------------
    # --model=<model>, -m <model>
    #-------------------------------------------------------------------

    ;; (--model=*)
      QLLM_MODEL=${1#*=}
      shift
      continue

    #-------------------------------------------------------------------
    # Long options with required arguments: --foo bar to --foo=bar
    #-------------------------------------------------------------------

    ;; ( \
      --model \
    )
      if (($# < 2)); then
        qsh_barf "$1 requires an argument"
      fi
      x=$1=$2
      shift 2
      set -- "$x" "$@"
      continue

    #-------------------------------------------------------------------
    # Short options with required arguments: -f bar to --foo=bar
    #-------------------------------------------------------------------

    ;; (-[m])
      if (($# < 2)); then
        qsh_barf "$1 requires an argument"
      fi
      x=${short_to_long[$1]}=$2
      shift 2
      set -- "$x" "$@"
      continue

    #-------------------------------------------------------------------
    # Short options with required arguments: -fbar to --foo=bar
    #-------------------------------------------------------------------

    ;; (-[m]?*)
      x=${short_to_long[${1:0:2}]}=${1:2}
      shift
      set -- "$x" "$@"
      continue

    #-------------------------------------------------------------------
    # Short options with forbidden arguments: -f to --foo
    #-------------------------------------------------------------------

    ;; (-[d])
      x=${short_to_long[$1]}
      shift
      set -- "$x" "$@"
      continue

    #-------------------------------------------------------------------
    # Short options with forbidden arguments: -fbar to --foo -bar
    #-------------------------------------------------------------------

    ;; (-[d]?*)
      x=${short_to_long[${1:0:2}]}
      y=-${1:2}
      shift
      set -- "$x" "$y" "$@"
      continue

    #-------------------------------------------------------------------
    # Long options incorrectly given arguments
    #-------------------------------------------------------------------

    ;; ( \
      --=* \
    )
      x=${1%%=*}
      qsh_barf "$x forbids an argument"

    #-------------------------------------------------------------------
    # Unknown long options
    #-------------------------------------------------------------------

    ;; (--*)
      x=${1%%=*}
      qsh_barf "Unknown option: ${x@Q}"

    #-------------------------------------------------------------------
    # Unknown short options
    #-------------------------------------------------------------------

    ;; (-?*)
      x=${1:0:2}
      qsh_barf "Unknown option: ${x@Q}"

    #-------------------------------------------------------------------
    esac
  fi

  if [[ ! ${session_file+x} ]]; then
    session_file=$1
  else
    qsh_barf "Too many operands"
  fi

  shift

done

if [[ ! ${session_file+x} ]]; then
  session_file=default.qllm
fi

session_file_new=$session_file.new
readonly session_file_new

if [[ ! ${QLLM_MODEL+x} ]]; then
  QLLM_MODEL=vertex-gemini-2.5-flash
fi

#-----------------------------------------------------------------------

unset vertex_bearer

vertex_init() {
  if [[ ! ${vertex_bearer+x} ]]; then
    vertex_bearer=$(gcloud auth print-access-token)
    vertex_project=$(gcloud config get-value project)
    vertex_location=us-central1
  fi
  completions_url="https://aiplatform.googleapis.com/v1beta1/projects/$vertex_project/locations/$vertex_location/endpoints/openapi/chat/completions"
  completions_bearer=$vertex_bearer
}; readonly -f vertex_init

#-----------------------------------------------------------------------

declare -A -r model_map=(
  # Listed in Google Cloud's web UI under Vertex AI > Model Garden.
  [vertex-gemini-2.5-flash]="google/gemini-2.5-flash"
  [vertex-gemini-2.5-pro]="google/gemini-2.5-pro"
  [vertex-gemini-3-pro-preview]="google/gemini-3-pro-preview"
)

declare -A -r init_functions=(
  [vertex-gemini-2.5-flash]=vertex_init
  [vertex-gemini-2.5-pro]=vertex_init
  [vertex-gemini-3-pro-preview]=vertex_init
)

#-----------------------------------------------------------------------
# Parse VISUAL and friends
#-----------------------------------------------------------------------

unset editor_bottom

if [[ ${VISUAL+x} ]]; then
  editor=$VISUAL
  if [[ ${VISUAL_BOTTOM+x} ]]; then
    editor_bottom=$VISUAL_BOTTOM
  fi
elif [[ ${EDITOR+x} ]]; then
  editor=$EDITOR
  if [[ ${EDITOR_BOTTOM+x} ]]; then
    editor_bottom=$EDITOR_BOTTOM
  fi
else
  editor=vi
  editor_bottom="-c '$'"
fi

if [[ ! ${editor_bottom+x} ]]; then
  case $editor in (vi | vim)
    editor_bottom="-c '$'"
  esac
fi

editor="$editor ${editor_bottom-}"
readonly editor

#-----------------------------------------------------------------------

gawk=gawk

printf -v blank_heading -- -%.s {1..72}
readonly blank_heading

user_heading='@@@ user '
user_heading+=${blank_heading:${#user_heading}}
readonly user_heading

model_heading='@@@ model '
model_heading+=${blank_heading:${#model_heading}}
readonly model_heading

#-----------------------------------------------------------------------

declare -r qllm_to_completions_gawk='

  function barf(message) {
    print(argv0 ": " message) >"/dev/stderr";
    exit_status = 1;
    exit exit_status;
  }

  function command_filter(x, c,    s) {
    printf("%s", x) |& c;
    s = close(c, "to");
    if (s != 0) {
      barf("Command failed: " c);
    }
    c |& getline x;
    s = close(c);
    if (s != 0) {
      barf("Command failed: " c);
    }
    return x;
  }

  function json_quote(x) {
    return command_filter(x, "jq -R -s .");
  }

  function base64_encode(x) {
    return command_filter(x, "base64");
  }

  function read_text_file(f,    xs, s, x) {
    xs = "";
    while ((s = (getline x < f)) > 0) {
      sub("[\t ]+$", "", x);
      xs = xs x "\n";
    }
    if (s < 0) {
      barf("Error reading file " json_quote(f));
    }
    s = close(f);
    if (s != 0) {
      barf("Error closing file " json_quote(f));
    }
    sub("^\n+", "", xs);
    sub("\n+$", "", xs);
    return xs;
  }

  function get_fence_type(filename) {
    if (filename ~ /\.[ch]$/) {
      return "c";
    }
    return "";
  }

  function add_text_content(    x, y) {
    x = buffer;
    buffer = "";
    if (heredoc) {
      if (x) {
        x = x "\n";
      }
      y = "Here is the content of the file `" heredoc "`:\n\n";
      x = y "```" get_fence_type(heredoc) "\n" x "```";
      heredoc = "";
    } else {
      sub("^[\n ]*", "", x);
      sub("[\n ]*$", "", x);
      if (!x) {
        return;
      }
    }
    x = json_quote(x);
    if (content) {
      content = content ", ";
    }
    content = content "{";
    content = content "\"type\": \"text\", ";
    content = content "\"text\": " x;
    content = content "}";
  }

  function add_message(role) {
    if (content) {
      content = "[" content "]";
    } else {
      content = "\" \"";
    }
    if (messages) {
      messages = messages ", ";
    }
    messages = messages "{";
    messages = messages "\"role\": \"" role "\", ";
    messages = messages "\"content\": " content;
    messages = messages "}";
    content = "";
  }

  BEGIN {
    buffer = system_prompt;
    add_text_content();
    add_message("system");
    role = "user";

    tools = "{";
    tools = tools "\"type\": \"function\", ";
    tools = tools "\"function\": {";
    tools = tools "\"name\": \"write_text_file\", ";
    tools = tools "\"description\": \"Create or overwrite a text file with the given content.\", ";
    tools = tools "\"parameters\": {";
    tools = tools "\"type\": \"object\", ";
    tools = tools "\"properties\": {";
    tools = tools "\"path\": {";
    tools = tools "\"type\": \"string\",";
    tools = tools "\"description\": \"A path to the text file to create or overwrite.\"";
    tools = tools "},";
    tools = tools "\"content\": {";
    tools = tools "\"type\": \"string\",";
    tools = tools "\"description\": \"The content to write to the text file.\"";
    tools = tools "}";
    tools = tools "},";
    tools = tools "\"required\": [\"path\", \"content\"]";
    tools = tools "}";
    tools = tools "}";
    tools = tools "}";
  }

  {
    if ($0 ~ /^@@@ *user[ -]*$/) {
      if (role == "assistant") {
        add_text_content();
        add_message(role);
        role = "user";
      }
    } else if ($0 ~ /^@@@ *model[ -]*$/) {
      if (role == "user") {
        add_text_content();
        add_message(role);
        role = "assistant";
      }
    } else if (role == "user") {
      z = $0;
      if (sub(/^@@@ *<< */, "", z)) {
        sub(/ *$/, "", z);
        if (!z && !heredoc) {
          barf("Orphan @@@<< block terminator");
        }
        add_text_content();
        heredoc = z;
      } else if (sub(/^@@@ *< */, "", z)) {
        sub(/ *$/, "", z);
        if (!z) {
          barf("The @@@< directive requires a filename");
        }
        if (heredoc) {
          barf("The @@@< directive cannot be used in a @@@<< block");
        }
        add_text_content();
        heredoc = z;
        buffer = read_text_file(heredoc);
        sub(/</, "<<", $0);
        $0 = $0 "\n" buffer "\n@@@<<";
        add_text_content();
      } else if ($0 ~ /^@@@/) {
        barf("Unknown directive: " $0);
      } else {
        if (buffer) {
          buffer = buffer "\n";
        }
        buffer = buffer $0;
      }
    } else {
      if ($0 ~ /^@@@/) {
        barf("Unknown directive: " $0);
      }
      if (buffer) {
        buffer = buffer "\n";
      }
      buffer = buffer $0;
    }
    print $0 > session_file_new;
  }

  END {
    if (exit_status) {
      exit exit_status;
    }
    add_text_content(buffer);
    add_message(role);
    body = "{";
    body = body "\"model\": " json_quote(model) ", ";
    body = body "\"messages\": [" messages "], ";
    body = body "\"tools\": [" tools "]";
    body = body "}";
    print body;
  }

'

#-----------------------------------------------------------------------

while :; do

  model=${model_map[$QLLM_MODEL]-}
  if [[ ! $model ]]; then
    qsh_barf "Unknown model: ${QLLM_MODEL@Q}"
  fi

  ${init_functions[$QLLM_MODEL]}

  if [[ -s "$session_file" ]]; then
    x=$(tail -n 3 -- "$session_file"; echo x)
    if [[ $x != "$user_heading"$'\n\n\nx' ]]; then
      printf '\n\n%s\n\n\n' "$user_heading" >>"$session_file"
    fi
  else
    printf '%s\n\n\n' "$user_heading" >>"$session_file"
  fi

  hash1=$(sha256sum -b -- "$session_file")

  eval " $editor -- ${session_file@Q}"

  hash2=$(sha256sum -b -- "$session_file")

  if [[ $hash1 == "$hash2" ]]; then
    break
  fi

  completions_request=$(
    eval " $gawk"' \
      -v argv0="$0" \
      -v model="$model" \
      -v session_file_new="$session_file_new" \
      -v sq="$sq" \
      -v system_prompt="$system_prompt" \
      -- \
      "$qllm_to_completions_gawk" \
      "$session_file" \
    ;'
  )

  mv -f -- "$session_file_new" "$session_file"

  if [[ ${QLLM_DEBUG+x} ]]; then
    printf 'completions_request = %s\n' "$completions_request" >&2
    x=$(jq . <<<"$completions_request" 2>&1 || :)
    printf 'parsed_completions_request = %s\n' "$x" >&2
  fi

  curl_with_retries \
    completions_response \
    "$completions_request" \
    '^(200)$' \
    '^(401)$' \
    -X POST \
    --url "$completions_url" \
    -H "Authorization: Bearer $completions_bearer" \
    -H "Content-Type: application/json" \
    --data-binary @- \
  ;

  if [[ ${QLLM_DEBUG+x} ]]; then
    printf 'completions_response = %s\n' "$completions_response" >&2
    x=$(jq . <<<"$completions_response" 2>&1 || :)
    printf 'parsed_completions_response = %s\n' "$x" >&2
  fi

  # TODO: Right now I'm just taking the model's write_text_file calls
  # and updating the model's response as if the files had been inlined.

  jq -r '
    .
    | .choices[0].message
    | [.content] + (.
      | .tool_calls // []
      | map(.
        | .function
        | select(.name == "write_text_file")
        | .arguments
        | fromjson
        | .content |= (if endswith("\n") then . else . + "\n" end)
        | "Here is the content of the file `\(.path)`:\n\n```\n\(.content)```"
        )
      )
    | map(select(.))
    | join("\n\n")
  ' <<<"$completions_response" | {
    printf '\n\n%s\n\n' "$model_heading"
    cat
  } >>"$session_file"

done
